## 核心设计理念：数据主权与工具透明性

> https://borretti.me/article/hashcards-plain-text-spaced-repetition

### 1. **"数据即代码"的哲学**

hashcards最激进的设计决策是**放弃传统数据库，改用纯文本Markdown文件**。这不仅是技术选择，更是一种价值宣言：

**数据主权**：作者明确表达了对数据掌控的焦虑——"如果它们存在于某个远程数据库里，或者只是电脑上一堆无法使用的晦涩数据，总感觉不太好"。这反映了对专有格式和平台锁定的深刻警惕。

**知识可见性**：Markdown文件让知识变得可读、可搜索、可版本控制。你的知识不再被封装在应用的黑箱里，而是以最原始、最持久的形式存在。

### 2. **Unix哲学的现代应用**

hashcards继承了Unix"小工具组合"的传统：

- **内容寻址**（通过哈希识别卡片）使得卡片具有不可变性和可追溯性
- **标准工具链**：可以用grep、awk、sed等工具操作卡片
- **管道思维**：脚本生成 → Markdown文件 → hashcards处理，形成清晰的数据流

这种设计让专业用户能够构建复杂的工作流，例如从CSV生成词汇卡、用Makefile管理多个数据源。

## 设计权衡：摩擦最小化原则

### 3. **认知负荷的精确计算**

作者对"摩擦"有近乎偏执的敏感。他的核心洞察是：

> "如果制作单词卡片很麻烦，你就会减少卡片的数量，这意味着你获得的知识也会减少"

**微观摩擦的累积效应**：
- Mochi的`{{1::produced}}`需要12个字符
- hashcards的`[produced]`只需11个字符（包括方括号）
- 作者甚至考虑到`[]`在美式键盘上不需要Shift键

这种极致优化背后是对**边际成本理论**的应用：每增加一个字符的输入，就会线性降低用户创建卡片的意愿。当你需要制作成百上千张卡片时，这种微小差异会被放大。

### 4. **格式演化的迭代过程**

作者经历了多次格式迭代：

**初版**：每行一张卡片，用`/`分隔
```
What is the atomic number of carbon? / 6
```

**问题**：多行卡片处理困难

**最终版**：显式标记
```
Q: What is the atomic number of carbon?
A: 6
```

这个演化过程体现了**形式追随功能**的设计原则：略微增加输入量（`Q:`和`A:`前缀），换取更好的可读性和语义清晰度。

## 算法与用户体验的博弈

### 5. **对"简单性陷阱"的批判**

作者对Mochi的算法提出尖锐批评：

> "理由是简单易懂：用户更容易理解算法。但我认为这毫无意义"

这触及了产品设计的一个根本问题：**透明性 vs. 有效性**

- Mochi选择简单的乘数算法，便于用户理解
- 作者认为用户不需要理解，只需要最佳效果

他的理想是：**"在最直观的界面下，采用最先进的计划算法"** —— 这是一种"魔法黑箱"哲学，用户只需享受结果，不必了解机制。

### 6. **"遗忘地狱"问题的深层分析**

作者描述了Mochi算法的致命缺陷：

> "如果一张卡片的间隔是60天，你点击'忘记'后，间隔并不会重置为1天...相反，间隔会乘以0.5，缩短到30天"

这暴露了一个心理学真相：**遗忘不是线性的**。如果你60天后忘记，说明记忆强度已经衰减到阈值以下，简单地缩短间隔无法解决根本问题。

FSRS算法通过对遗忘曲线的精确建模解决了这个问题，这是hashcards选择FSRS的核心原因。

## 知识演化与编辑性

### 7. **"知识的时间性"问题**

作者敏锐地观察到：

> "教科书通常采用这种方式：第一章介绍一种本体论，到了第三章却告诉你'其实之前说的都是错的'"

这是学习的本质特征：**知识是递进式的，会自我否定和重构**。传统SR应用把卡片视为静态实体，但实际上：

- 你对概念的理解会深化
- 术语定义会随学科深入而变化
- 需要频繁回溯修改旧卡片

hashcards的纯文本+Git方案完美应对这一点：
- 文件结构按章节组织，便于定位相关卡片
- 语义相关的卡片在物理上相邻
- Git历史完整记录概念理解的演化轨迹

## 社会性与开放性

### 8. **知识共享的愿景**

作者提出了一个激进想法：

> "我常常希望人们能更多地分享自己...为什么不分享他们的记忆卡片呢？"

这体现了**开源精神在学习领域的扩展**。传统上，人们分享博客文章和代码，但很少分享学习笔记。hashcards通过Git+GitHub基础设施，让"知识开源"成为可能。

**潜在价值**：
- 看到专家如何组织知识
- 发现新的学习路径
- 形成学习社区和知识网络

## 元层面的设计哲学

### 9. **"负空间设计"**

作者说hashcards"就像一个形状完美的空洞，我只需要把它填满就行了"。这揭示了一个有趣的现象：

他在使用Mochi时**自发地创建了类似hashcards的工作流**：
1. 用Markdown写卡片
2. 用脚本转换格式
3. 手动导入Mochi

hashcards的诞生不是从零构思，而是**将已有的自组织行为系统化**。最好的工具往往是对用户自然行为的形式化。

### 10. **反中心化的权力结构**

对比三个应用的权力分布：

| 应用 | 权力中心 | 用户自主性 |
|------|---------|-----------|
| Anki | 应用+插件生态 | 中等（依赖插件） |
| Mochi | 应用本身 | 低（封闭系统） |
| hashcards | 用户+工具链 | 高（数据完全可控） |

hashcards通过将核心数据格式交还给用户，实现了**权力下放**。用户不再是消费者，而是创造者和维护者。

## 批判性反思

### 潜在局限

1. **学习曲线**：纯文本方案对非技术用户不友好
2. **同步复杂性**：多设备同步需要Git知识
3. **功能取舍**：放弃了富媒体（图片、音频）的便利性
4. **抽象漏出**：内容寻址、哈希等概念可能让普通用户困惑

### 适用人群

hashcards明确针对的是：
- 技术背景用户
- 重度学习者（大量卡片）
- 重视数据主权的人
- 需要自动化工作流的专业人士

## 结论：工具哲学的范式

hashcards代表了一种设计哲学的集大成：

1. **Unix哲学**（小工具、文本流、可组合性）
2. **开源精神**（透明、可控、共享）
3. **认知工程学**（最小化摩擦、优化工作流）
4. **数据主权运动**（用户拥有数据）

它的真正创新不在于技术实现，而在于**重新定义了学习工具与用户的关系**：从"应用-用户"的主从关系，转变为"工具-创造者"的协作关系。

这种设计思路对其他领域也有启发：任何处理个人重要数据的应用（笔记、任务管理、财务等），都可以思考——我们是否过度依赖专有格式？是否可以让数据回归纯文本和开放标准？

hashcards的成功将取决于技术用户群体是否足够大，以及这种"极客友好但大众陌生"的设计能否找到平衡点。但无论如何，它已经提供了一个重要的概念证明：**学习工具可以是开放、透明、用户完全掌控的**。
